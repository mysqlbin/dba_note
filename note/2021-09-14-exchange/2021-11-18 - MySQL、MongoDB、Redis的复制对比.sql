
MySQL：
	
	主动发送binlog给从库
	中介日志(复制的基石)：二进制binlog文件 
	
MongoDB：
	
	从库主动去主库拉取oplog，只拉取大于自己当前oplog最新时间戳的oplog记录
	2021-11-18，口述了才知道自己的表达能力。
	
	主从复制是由从节点的线程发起的：
		1：检查自己local库的oplog.rs集合找出最新的时间戳。
		2：从 主库节点local库oplog.rs集合，查询大于此时间戳的记录。
		3：将找到的记录插入到自己的oplog.rs集合中，并执行这些操作。
		
	主从复制是由从节点的线程发起的。通过监听主节点的oplog表的变化，并把oplog的entries(记录) pull到从节点进行回放。
	
	
	中介日志(复制的基石)：oplog.rs集合
	
	
Redis：

	主库主动发送命令给从库
	
	中介日志：无
	
	直接发送在主库执行的增删改操作命令给从库执行 
	
	0. 从库跟主库建立连接后，向主库发送sync同步命令
	1. 主库执行 bgsave 命令，备份数据到RDB文件，增量数据则写入缓冲区中
	2. 备份完成，向从库发送RDB文件
	3. 从库接收RDB文件后，先清空所有的数据，再导入RDB文件
	4. 将缓冲区的增量数据发送从库，从库执行写增量数据的命令
	5. 发送在主库执行的增删改操作命令给从库执行
	
	
	
	
小结：
	
	redis主从复制，不需要类似binlog或者oplog来存储逻辑日志然后再发送给从库。

	Redis -> backlog  基于复制偏移量
	MongoDB -> oplog  基于时间戳
	MySQL -> binlog   基于位点或者GTID




思考：
	oplog里面的日志，记录的是命令吗

----------------------------------------------------------------------------------------------------

MySQL 主从原理、延迟的原因、如何避免主从延迟

	主从原理：
		主库有事务提交，就会唤醒dump线程，把binlog日志发送给从库的IO线程
		IO线程负责接收binlog和写入binlog到中转日志里面 
		SQL线程负责解析中转日志里的命令，并执行，让从库的数据跟主库的数据保持一致。
		
	扩展讲一下主从延迟的原因和对应的解决办法	
		
	主从延迟的原因和对应的解决办法：

		主要是主库是多线程的，从库是单线程的复制、还有大事务导致的延迟、从库查询压力大导致的延迟 --不够全面
		
		1. 主库高并发导致的延迟
			看tps、qps
			
			解决办法：
				1. 从库设置为非双1
				2. 启用多线程复制(默认使用、对应的参数是怎么定的？)
				
		2. 大事务导致的延迟
			
			大事务又分为DML大事务、DDL大事务
			DML大事务：可以把大事务拆分为小事务进行提交  -- 这个没有提到。
			DDL大事务：
				分为操作字段、操作索引
				操作字段：
					1. 如果是8.0的社区版本，可以快速加列，但是需要加在表的最后一列。腾讯云数据库5.7版本，支持快速加列。
						-- 注意：快速加列是需要加MDL写锁的，不能在表上有慢查询的时候加列。并且，需要实时监控MDL元数据锁；
					2. 非8.0版本，可以用第3方工具来做，比如pt-osc或者gh-ost，同时从库要设置非1，避免从库有延迟
				操作索引：
					添加索引：可以用第3方工具来做，也可以分别在主库和从库执行添加索引操作
					删除索引： 直接Online DDL 就好，执行速度很快，这部分的源码有看过，删除二级索引，会直接释放索引树，不需要扫描二级索引的所有记录。
					
				最终，相关操作都要在业务低峰期执行。
				
		3. 从库查询压力大导致的延迟
			
			如果从库查询压力大，导致CPU和IO利用率高，也是会导致主从延迟的
			
			解决办法：	
				增加从库，分担一部的查询压力。
			
			场景：
				代码bug(变更导致)、用户从平台上批量导数据；
				2023-02-13 - 业务变更产生的慢sql非常多导致从库cpu打满，进而导致主从延迟
				2023-01-05 - 高并发update导致主从延迟
				2022-11-01 - 主从延迟案例-从库cpu资源持续打满
		
		4. 从库配置低，但是并发高；
		
				
	如何判断主从是否有延迟
		
		1. 首先，要确保IO线程和SQL线程的状态值为YES
		
		2. 查看主从是否有延迟的3种方式
			1. 查看 seconds_behind_master 的值是否大小0
			
			2. 对比binlog位点
				IO线程：master_log_file、read_master_log_pos = SQL线程：relay_master_log_file、exec_master_log_pos 
				
			3. 对比GTID
				从库已经接收到的GTID = 从库已经执行的GTID
				
				
	
		
			
		
		